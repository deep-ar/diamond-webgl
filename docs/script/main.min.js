/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/drawer.ts":
/*!**************************!*\
  !*** ./src/ts/drawer.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Drawer = void 0;
var vbo_1 = __webpack_require__(/*! ./gl-utils/vbo */ "./src/ts/gl-utils/vbo.ts");
var orbital_camera_1 = __webpack_require__(/*! ./orbital-camera */ "./src/ts/orbital-camera.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var lazy_shader_1 = __webpack_require__(/*! ./lazy-shader */ "./src/ts/lazy-shader.ts");
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var UNIT_CUBE = new Float32Array([
    -.5, -.5, -.5,
    -.5, -.5, +.5,
    +.5, -.5, -.5,
    +.5, -.5, -.5,
    -.5, -.5, +.5,
    +.5, -.5, +.5,
    +.5, -.5, -.5,
    +.5, -.5, +.5,
    +.5, +.5, -.5,
    +.5, +.5, -.5,
    +.5, -.5, +.5,
    +.5, +.5, +.5,
    -.5, -.5, +.5,
    -.5, +.5, +.5,
    +.5, -.5, +.5,
    +.5, -.5, +.5,
    -.5, +.5, +.5,
    +.5, +.5, +.5,
    -.5, +.5, -.5,
    +.5, +.5, -.5,
    -.5, +.5, +.5,
    +.5, +.5, -.5,
    +.5, +.5, +.5,
    -.5, +.5, +.5,
    -.5, -.5, -.5,
    -.5, +.5, -.5,
    -.5, -.5, +.5,
    -.5, +.5, -.5,
    -.5, +.5, +.5,
    -.5, -.5, +.5,
    -.5, -.5, -.5,
    +.5, -.5, -.5,
    -.5, +.5, -.5,
    +.5, -.5, -.5,
    +.5, +.5, -.5,
    -.5, +.5, -.5,
]);
var Drawer = (function () {
    function Drawer(gl) {
        var _this = this;
        Page.Canvas.showLoader(true);
        this.gl = gl;
        this.cubeVBO = new vbo_1.VBO(gl, UNIT_CUBE, 3, gl.FLOAT, true);
        this.geometryVBO = gl.createBuffer();
        this.shader = new lazy_shader_1.LazyShader("shader.frag", "shader.vert", "default shader");
        this.shaderMulticolor = new lazy_shader_1.LazyShader("shader-multicolor.frag", "shader.vert", "shader with dispersion");
        this.raytracedVolumeShader = new lazy_shader_1.LazyShader("raytracedVolume.frag", "raytracedVolume.vert", "debug raytraced shader");
        this.normalsShader = new lazy_shader_1.LazyShader("normals.frag", "shader.vert", "normals shader");
        this.shadersSkybox = new lazy_shader_1.LazyShader("skybox.frag", "skybox.vert", "skybox shader");
        this.pMatrix = mat4.create();
        this.mvpMatrix = mat4.create();
        this.camera = new orbital_camera_1.OrbitalCamera([0, 0, 0], 1.5);
        this.camera.phi = 1;
        this.camera.theta = 2;
        var EPSILON = 0.0001;
        var minPhi = EPSILON;
        var maxPhi = Math.PI - EPSILON;
        Page.Canvas.Observers.mouseDrag.push(function (dX, dY) {
            _this.camera.theta -= 0.5 * 2 * 3.14159 * dX;
            _this.camera.phi -= 0.5 * 2 * 3 * dY;
            _this.camera.phi = Math.min(maxPhi, Math.max(minPhi, _this.camera.phi));
            _this.updateMVPMatrix();
        });
        var minDist = 0.8;
        var maxDist = 8;
        Page.Canvas.Observers.mouseWheel.push(function (delta) {
            var d = _this.camera.distance + 0.2 * delta;
            d = Math.min(maxDist, Math.max(minDist, d));
            _this.camera.distance = d;
            _this.updateMVPMatrix();
        });
        Page.Canvas.Observers.canvasResize.push(function () {
            _this.updateMVPMatrix();
        });
        parameters_1.Parameters.addCameraChangeObservers(function () {
            _this.updateMVPMatrix();
        });
        this.updateMVPMatrix();
        gl.enable(gl.CULL_FACE);
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        function updateBackgroundColor() {
            var backgroundColor = parameters_1.Parameters.backgroundColor;
            gl.clearColor(backgroundColor.r / 255, backgroundColor.g / 255, backgroundColor.b / 255, 0.1);
        }
        parameters_1.Parameters.addBackgroundColorObserver(updateBackgroundColor);
        updateBackgroundColor();
        var recomputeShader = function () {
            var injectedForGemstone = _this.computeInjectedInstructions();
            _this.shader.reset(injectedForGemstone);
        };
        parameters_1.Parameters.addRecomputeShaderObservers(recomputeShader);
    }
    Drawer.prototype.setGemstone = function (gemstone) {
        if (this.gemstone !== gemstone) {
            this.gemstone = gemstone;
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.geometryVBO);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, gemstone.bufferData, this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            var injectedForGemstone = this.computeInjectedInstructions();
            this.shader.reset(injectedForGemstone);
            this.shaderMulticolor.reset(injectedForGemstone);
            this.raytracedVolumeShader.reset(injectedForGemstone);
            Page.Canvas.setIndicatorText("triangles-count-indicator", gemstone.nbTriangles.toString());
            Page.Canvas.setIndicatorText("facets-count-indicator", gemstone.facets.length.toString());
            var CONVEXITY_ERROR_KEY = "shape_not_convex";
            if (this.gemstone.isConvex) {
                Page.Demopage.setErrorMessage(CONVEXITY_ERROR_KEY, "");
            }
            else {
                Page.Demopage.setErrorMessage(CONVEXITY_ERROR_KEY, "The current geometry is not supported. The simulation will not look as expected.");
            }
        }
    };
    Drawer.prototype.rotate = function (deltaAngle) {
        this.camera.theta += deltaAngle;
        this.updateMVPMatrix();
    };
    Drawer.prototype.draw = function () {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        if (parameters_1.Parameters.displaySkybox) {
            this.drawSkybox();
        }
        if (!this.gemstone) {
            return;
        }
        var shader;
        if (parameters_1.Parameters.geometryOnly) {
            shader = this.normalsShader.shader;
            if (!shader) {
                return;
            }
        }
        else {
            var isASETSkybox = (parameters_1.Parameters.lightType === parameters_1.ELightType.ASET);
            var baseRefractionIndex = parameters_1.Parameters.refractionIndex;
            var wantedDispersion = parameters_1.Parameters.dispersion;
            var dispersion = Math.min(wantedDispersion, baseRefractionIndex - 1);
            var useSimpleShader = (dispersion <= 0) || isASETSkybox || parameters_1.Parameters.displayNormals;
            if (useSimpleShader) {
                shader = this.shader.shader;
                if (!shader) {
                    return;
                }
                shader.u["uRefractionIndex"].value = parameters_1.Parameters.refractionIndex;
                shader.u["uASETSkybox"].value = isASETSkybox ? 1 : 0;
                shader.u["uDisplayNormals"].value = parameters_1.Parameters.displayNormals ? 1 : 0;
            }
            else {
                shader = this.shaderMulticolor.shader;
                if (!shader) {
                    return;
                }
                shader.u["uRefractionIndices"].value = [
                    baseRefractionIndex - 0.5 * dispersion,
                    baseRefractionIndex,
                    baseRefractionIndex + 0.5 * dispersion,
                ];
            }
            shader.u["uEyePosition"].value = this.camera.eyePos;
            shader.u["uOrthographic"].value = (parameters_1.Parameters.projection === parameters_1.EProjection.ORTHOGRAPHIC) ? 1 : 0;
            shader.u["uLightDirection"].value = (parameters_1.Parameters.lightDirection === parameters_1.ELightDirection.DOWNWARD) ? 1 : -1;
            shader.u["uDisplayReflection"].value = parameters_1.Parameters.displayReflection ? 1 : 0;
            if (typeof shader.u["uAbsorption"] !== "undefined") {
                var gemAbsorption = parameters_1.Parameters.absorption;
                var gemColor = isASETSkybox ? { r: 250, g: 250, b: 250 } : parameters_1.Parameters.gemColor;
                shader.u["uAbsorption"].value = [
                    gemAbsorption * (1 - gemColor.r / 255),
                    gemAbsorption * (1 - gemColor.g / 255),
                    gemAbsorption * (1 - gemColor.b / 255),
                ];
            }
        }
        Page.Canvas.showLoader(false);
        shader.u["uMVPMatrix"].value = this.mvpMatrix;
        shader.use();
        var BYTES_PER_FLOAT = 4;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.geometryVBO);
        var aPositionLoc = shader.a["aPosition"].loc;
        this.gl.enableVertexAttribArray(aPositionLoc);
        this.gl.vertexAttribPointer(aPositionLoc, 3, this.gl.FLOAT, false, 2 * 3 * BYTES_PER_FLOAT, 0);
        var aNormalLoc = shader.a["aNormal"].loc;
        this.gl.enableVertexAttribArray(aNormalLoc);
        this.gl.vertexAttribPointer(aNormalLoc, 3, this.gl.FLOAT, false, 2 * 3 * BYTES_PER_FLOAT, 3 * BYTES_PER_FLOAT);
        shader.bindUniformsAndAttributes();
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 3 * this.gemstone.nbTriangles);
    };
    Drawer.prototype.drawDebugVolume = function () {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        if (this.gemstone) {
            var shader = this.raytracedVolumeShader.shader;
            if (shader) {
                Page.Canvas.showLoader(false);
                shader.a["aPosition"].VBO = this.cubeVBO;
                shader.u["uMVPMatrix"].value = this.mvpMatrix;
                shader.u["uEyePosition"].value = this.camera.eyePos;
                shader.u["uOrthographic"].value = (parameters_1.Parameters.projection === parameters_1.EProjection.ORTHOGRAPHIC) ? 1 : 0;
                shader.use();
                shader.bindUniformsAndAttributes();
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 3 * 2 * 6);
            }
        }
    };
    Drawer.prototype.drawSkybox = function () {
        var skyboxShader = this.shadersSkybox.shader;
        if (skyboxShader) {
            skyboxShader.a["aPosition"].VBO = this.cubeVBO;
            skyboxShader.u["uMVPMatrix"].value = this.mvpMatrix;
            skyboxShader.u["uEyePosition"].value = this.camera.eyePos;
            skyboxShader.u["uOrthographic"].value = (parameters_1.Parameters.projection === parameters_1.EProjection.ORTHOGRAPHIC) ? 1 : 0;
            skyboxShader.u["uASETSkybox"].value = (parameters_1.Parameters.lightType === parameters_1.ELightType.ASET) ? 1 : 0;
            skyboxShader.u["uLightDirection"].value = (parameters_1.Parameters.lightDirection === parameters_1.ELightDirection.DOWNWARD) ? 1 : -1;
            skyboxShader.use();
            skyboxShader.bindUniformsAndAttributes();
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 3 * 2 * 6);
        }
    };
    Drawer.prototype.updateMVPMatrix = function () {
        var zNear = 0.1;
        var zFar = 50.0;
        var aspectRatio = Page.Canvas.getAspectRatio();
        if (parameters_1.Parameters.projection === parameters_1.EProjection.PERSPECTIVE) {
            mat4.perspective(this.pMatrix, 45, aspectRatio, zNear, zFar);
        }
        else {
            var distance = 0.5 * this.camera.distance;
            mat4.ortho(this.pMatrix, -distance * aspectRatio, distance * aspectRatio, -distance, distance, zNear, zFar);
        }
        mat4.multiply(this.mvpMatrix, this.pMatrix, this.camera.viewMatrix);
    };
    Drawer.prototype.computeInjectedInstructions = function () {
        var facetsDefinitionInstructions = [];
        var computeEntryPointInstructions = [];
        var checkIfInsideInstructions = [];
        var computeInternalIntersectionInstructions = [];
        for (var i = 0; i < this.gemstone.facets.length; i++) {
            var facet = this.gemstone.facets[i];
            var facetPointName = "FACET_" + i + "_POINT";
            var facetNormalName = "FACET_" + i + "_NORMAL";
            facetsDefinitionInstructions.push("const vec3 " + facetPointName + " = vec3(" + facet.point.x + "," + facet.point.y + "," + facet.point.z + ");");
            facetsDefinitionInstructions.push("const vec3 " + facetNormalName + " = vec3(" + facet.normal.x + "," + facet.normal.y + "," + facet.normal.z + ");");
            computeEntryPointInstructions.push("computeIntersectionWithPlane(" + facetPointName + ", " + facetNormalName + ", eyePosition, fromEyeNormalized, theta, facetNormal);");
            checkIfInsideInstructions.push("isInside(" + facetPointName + ", " + facetNormalName + ", entryPoint)");
            computeInternalIntersectionInstructions.push("checkNextInternalIntersection(" + facetPointName + ", " + facetNormalName + ", position, direction, theta, facetNormal);");
        }
        return {
            FACETS_DEFINITION: facetsDefinitionInstructions.join("\n"),
            COMPUTE_ENTRY_POINT: computeEntryPointInstructions.join("\n\t"),
            CHECK_IF_INSIDE: checkIfInsideInstructions.join(" && "),
            COMPUTE_INTERNAL_INTERSECTION: computeInternalIntersectionInstructions.join("\n\t"),
            RAY_DEPTH: parameters_1.Parameters.rayDepth.toString(),
        };
    };
    return Drawer;
}());
exports.Drawer = Drawer;


/***/ }),

/***/ "./src/ts/fps-indicator.ts":
/*!*********************************!*\
  !*** ./src/ts/fps-indicator.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerFrame = void 0;
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var framesSinceLastFPSUpdate = 0;
var timeOfLastFPSUpdate = performance.now();
setInterval(function () {
    var now = performance.now();
    var fps = 1000 * framesSinceLastFPSUpdate / (now - timeOfLastFPSUpdate);
    timeOfLastFPSUpdate = now;
    framesSinceLastFPSUpdate = 0;
    Page.Canvas.setIndicatorText("fps-indicator", Math.round(fps).toString());
}, 500);
function registerFrame() {
    framesSinceLastFPSUpdate++;
}
exports.registerFrame = registerFrame;


/***/ }),

/***/ "./src/ts/gemstone.ts":
/*!****************************!*\
  !*** ./src/ts/gemstone.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Gemstone = void 0;
var geometry_1 = __webpack_require__(/*! ./geometry */ "./src/ts/geometry.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
function logParsingInfo(message) {
    if (parameters_1.Parameters.verbose) {
        console.log("OBJ parsing:  " + message);
    }
}
var knownGemstones = {};
var Gemstone = (function () {
    function Gemstone(triangles) {
        Gemstone.mutualizeTrianglesVertices(triangles);
        this.nbTriangles = triangles.length;
        this.bufferData = Gemstone.buildBufferFromTriangles(triangles);
        this.facets = Gemstone.buildFacetsFromTriangles(triangles);
        var vertices = [];
        for (var _i = 0, triangles_1 = triangles; _i < triangles_1.length; _i++) {
            var triangle = triangles_1[_i];
            vertices.push(triangle.p1);
            vertices.push(triangle.p2);
            vertices.push(triangle.p3);
        }
        this.isConvex = Gemstone.checkConvexity(vertices, this.facets);
        if (!this.isConvex) {
            console.log("This shape is not convex :(.");
        }
    }
    Gemstone.loadGemstone = function (name, callback) {
        if (name === "CUSTOM CUT") {
            callback(Gemstone.customCut());
        }
        else if (typeof knownGemstones[name] !== "undefined") {
            callback(knownGemstones[name]);
        }
        else {
            var request_1 = new XMLHttpRequest();
            request_1.addEventListener("load", function () {
                if (request_1.status === 200) {
                    if (typeof knownGemstones[name] === "undefined") {
                        knownGemstones[name] = Gemstone.fromObj(request_1.responseText);
                    }
                    callback(knownGemstones[name]);
                }
                else {
                    callback(null);
                }
            });
            request_1.open("GET", "models/" + name + "?v=" + Page.version);
            request_1.send();
        }
    };
    Gemstone.fromObj = function (input) {
        var lines = input.split("\n");
        var vertices = [];
        var triangles = [];
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
            var lineItems = line.split(/\s+/);
            var command = lineItems[0];
            if (command === "v") {
                if (lineItems.length >= 4) {
                    vertices.push({
                        x: parseFloat(lineItems[1]),
                        y: parseFloat(lineItems[2]),
                        z: parseFloat(lineItems[3]),
                    });
                }
                else {
                    logParsingInfo("Ignoring line " + i + " because it does not have enough items: '" + line + "'.");
                    continue;
                }
            }
            else if (command === "f") {
                if (lineItems.length >= 4) {
                    for (var iV = 3; iV < lineItems.length; iV++) {
                        var indices = [
                            +(lineItems[1].split("/")[0]),
                            +(lineItems[iV - 1].split("/")[0]),
                            +(lineItems[iV].split("/")[0]),
                        ];
                        for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                            var indice = indices_1[_i];
                            if (indice < 1 || indice >= vertices.length) {
                                logParsingInfo("Ignoring line " + i + " because vertex index " + indice + " is out of range: '" + line + "'.");
                                continue;
                            }
                        }
                        triangles.push({
                            p1: vertices[indices[0] - 1],
                            p2: vertices[indices[1] - 1],
                            p3: vertices[indices[2] - 1],
                        });
                    }
                }
                else {
                    logParsingInfo("Ignoring line " + i + " because only triangular faces are supported: '" + line + "'.");
                    continue;
                }
            }
            else {
                logParsingInfo("Ignoring line " + i + ": '" + line + "'.");
                continue;
            }
        }
        return new Gemstone(triangles);
    };
    Gemstone.customCut = function () {
        var triangles = Gemstone.computeBrilliantCut();
        return new Gemstone(triangles);
    };
    Gemstone.buildBufferFromTriangles = function (triangles) {
        var nbFloatsPerTriangle = (3 + 3) * 3;
        var bufferData = new Float32Array(nbFloatsPerTriangle * triangles.length);
        var i = 0;
        for (var _i = 0, triangles_2 = triangles; _i < triangles_2.length; _i++) {
            var triangle = triangles_2[_i];
            var normal = geometry_1.computeTriangleNormal(triangle);
            bufferData[i++] = triangle.p1.x;
            bufferData[i++] = triangle.p1.y;
            bufferData[i++] = triangle.p1.z;
            bufferData[i++] = normal.x;
            bufferData[i++] = normal.y;
            bufferData[i++] = normal.z;
            bufferData[i++] = triangle.p2.x;
            bufferData[i++] = triangle.p2.y;
            bufferData[i++] = triangle.p2.z;
            bufferData[i++] = normal.x;
            bufferData[i++] = normal.y;
            bufferData[i++] = normal.z;
            bufferData[i++] = triangle.p3.x;
            bufferData[i++] = triangle.p3.y;
            bufferData[i++] = triangle.p3.z;
            bufferData[i++] = normal.x;
            bufferData[i++] = normal.y;
            bufferData[i++] = normal.z;
        }
        return bufferData;
    };
    Gemstone.buildFacetsFromTriangles = function (triangles) {
        var result = [];
        for (var _i = 0, triangles_3 = triangles; _i < triangles_3.length; _i++) {
            var triangle = triangles_3[_i];
            var knownFacet = false;
            for (var _a = 0, result_1 = result; _a < result_1.length; _a++) {
                var registeredPlane = result_1[_a];
                if (geometry_1.isInPlane(registeredPlane, triangle.p1) && geometry_1.isInPlane(registeredPlane, triangle.p2) && geometry_1.isInPlane(registeredPlane, triangle.p3)) {
                    knownFacet = true;
                    break;
                }
            }
            if (!knownFacet) {
                result.push(geometry_1.computePlaneFromTriangle(triangle));
            }
        }
        return result;
    };
    Gemstone.checkConvexity = function (vertices, facets) {
        for (var _i = 0, vertices_1 = vertices; _i < vertices_1.length; _i++) {
            var vertice = vertices_1[_i];
            if (!geometry_1.isInsideVolume(facets, vertice)) {
                return false;
            }
        }
        return true;
    };
    Gemstone.computeBrilliantCut = function () {
        var CROWN_SIZE = 1;
        var HALF_CROWN_SIZE = 0.5 * CROWN_SIZE;
        var PAVILION_HEIGHT = parameters_1.Parameters.customCutPavillionHeight;
        var PAVILION_STEP = parameters_1.Parameters.customCutPavillionRati;
        var GIRDLE_THICKNESS = parameters_1.Parameters.customCutGirdleThickness;
        var GIRDLE_ROUNDNESS = parameters_1.Parameters.customCutGirdleRoundess;
        var CROWN_DEPTH = parameters_1.Parameters.customCutCrownHeight;
        var CROWN_RATIO = parameters_1.Parameters.customCutCrownRatio;
        var TABLE_SIZE = parameters_1.Parameters.customCutCrownTable;
        var CROWN_HEIGHT = GIRDLE_THICKNESS + CROWN_DEPTH;
        var vertex0 = { x: 0, y: 0, z: -PAVILION_HEIGHT };
        var vertex1 = geometry_1.cylindric((1 - PAVILION_STEP) * HALF_CROWN_SIZE / Math.cos(2 * Math.PI / 16), 2 * Math.PI / 8, -PAVILION_HEIGHT * PAVILION_STEP);
        var vertex2 = geometry_1.rotateZ(vertex1, -2 * Math.PI / 8);
        var vertex3 = geometry_1.cylindric(HALF_CROWN_SIZE, 2 * 2 * Math.PI / 16, 0);
        var vertex4 = geometry_1.cylindric(HALF_CROWN_SIZE, 1 * 2 * Math.PI / 16, 0);
        var vertex5 = geometry_1.cylindric(HALF_CROWN_SIZE, 0 * 2 * Math.PI / 16, 0);
        var vertex6 = { x: vertex3.x, y: vertex3.y, z: GIRDLE_THICKNESS };
        var vertex7 = { x: vertex4.x, y: vertex4.y, z: GIRDLE_THICKNESS };
        var vertex8 = { x: vertex5.x, y: vertex5.y, z: GIRDLE_THICKNESS };
        var vertex9 = geometry_1.cylindric(0.5 * ((1 - CROWN_RATIO) * CROWN_SIZE + CROWN_RATIO * TABLE_SIZE) / Math.cos(2 * Math.PI / 16), 2 * Math.PI / 8, GIRDLE_THICKNESS + CROWN_RATIO * CROWN_DEPTH);
        var vertex10 = geometry_1.rotateZ(vertex9, -2 * Math.PI / 8);
        var vertex11 = geometry_1.cylindric(0.5 * TABLE_SIZE, 1 * 2 * Math.PI / 16, CROWN_HEIGHT);
        var vertex12 = geometry_1.cylindric(0.5 * TABLE_SIZE, -1 * 2 * Math.PI / 16, CROWN_HEIGHT);
        var vertex13 = { x: 0, y: 0, z: CROWN_HEIGHT };
        var lowerFacet1 = geometry_1.computePlaneFromTriangle({ p1: vertex2, p3: vertex5, p2: vertex4 });
        var lowerFacet2 = geometry_1.computePlaneFromTriangle({ p1: vertex1, p3: vertex4, p2: vertex3 });
        var higherFacet1 = geometry_1.computePlaneFromTriangle({ p1: vertex7, p3: vertex8, p2: vertex10 });
        var higherFacet2 = geometry_1.computePlaneFromTriangle({ p1: vertex6, p3: vertex7, p2: vertex9 });
        var triangles = [];
        for (var iSide = 0; iSide < 2; iSide++) {
            var lowerFacet = (iSide === 0) ? lowerFacet1 : lowerFacet2;
            var higherFacet = (iSide === 0) ? higherFacet1 : higherFacet2;
            var lowerBaseVertex = (iSide === 0) ? vertex2 : vertex1;
            var upperBaseVertex = (iSide === 0) ? vertex10 : vertex9;
            var nbPoints = GIRDLE_ROUNDNESS + 2;
            var deltaAngle = 2 * Math.PI / 16 / (nbPoints - 1);
            var sideBaseAngle = iSide * 2 * Math.PI / 16;
            for (var iP = 0; iP < nbPoints - 1; iP++) {
                var angle = sideBaseAngle + iP * deltaAngle;
                var lowerN = geometry_1.computeIntersection(geometry_1.cylindric(HALF_CROWN_SIZE, angle, 0), { x: 0, y: 0, z: 1 }, lowerFacet);
                var lowerNplus = geometry_1.computeIntersection(geometry_1.cylindric(HALF_CROWN_SIZE, angle + deltaAngle, 0), { x: 0, y: 0, z: 1 }, lowerFacet);
                var upperN = geometry_1.computeIntersection(geometry_1.cylindric(HALF_CROWN_SIZE, angle, 0), { x: 0, y: 0, z: 1 }, higherFacet);
                var upperNplus = geometry_1.computeIntersection(geometry_1.cylindric(HALF_CROWN_SIZE, angle + deltaAngle, 0), { x: 0, y: 0, z: 1 }, higherFacet);
                triangles.push({ p1: lowerBaseVertex, p3: lowerN, p2: lowerNplus });
                triangles.push({ p1: lowerNplus, p3: lowerN, p2: upperN });
                triangles.push({ p1: lowerNplus, p3: upperN, p2: upperNplus });
                triangles.push({ p1: upperBaseVertex, p3: upperNplus, p2: upperN });
            }
        }
        triangles.push({ p1: vertex0, p3: vertex2, p2: vertex4 });
        triangles.push({ p1: vertex0, p3: vertex4, p2: vertex1 });
        triangles.push({ p1: vertex11, p3: vertex12, p2: vertex13 });
        triangles.push({ p1: vertex11, p3: vertex10, p2: vertex12 });
        triangles.push({ p1: vertex7, p3: vertex10, p2: vertex11 });
        triangles.push({ p1: vertex7, p3: vertex11, p2: vertex9 });
        var nbTrianglesForOneEighth = triangles.length;
        for (var i = 1; i < 8; i++) {
            for (var iT = 0; iT < nbTrianglesForOneEighth; iT++) {
                triangles.push({
                    p1: geometry_1.rotateZ(triangles[iT].p1, i * 2 * Math.PI / 8),
                    p2: geometry_1.rotateZ(triangles[iT].p2, i * 2 * Math.PI / 8),
                    p3: geometry_1.rotateZ(triangles[iT].p3, i * 2 * Math.PI / 8),
                });
            }
        }
        return triangles;
    };
    Gemstone.mutualizeTrianglesVertices = function (triangles) {
        var nbPointsSaved = 0;
        var knownVerticesStore = {};
        var precision = Math.pow(10, 8);
        function round(x) {
            return Math.round(precision * x);
        }
        function getSimilarVerticeFromStore(point) {
            var hash = round(point.x) + "_" + round(point.y) + "_" + round(point.z);
            if (typeof knownVerticesStore[hash] === "undefined") {
                knownVerticesStore[hash] = point;
            }
            else {
                nbPointsSaved++;
            }
            return knownVerticesStore[hash];
        }
        for (var _i = 0, triangles_4 = triangles; _i < triangles_4.length; _i++) {
            var triangle = triangles_4[_i];
            triangle.p1 = getSimilarVerticeFromStore(triangle.p1);
            triangle.p2 = getSimilarVerticeFromStore(triangle.p2);
            triangle.p3 = getSimilarVerticeFromStore(triangle.p3);
        }
        logParsingInfo("After mutualization: " + Object.keys(knownVerticesStore).length + " vertices (saved " + nbPointsSaved + " vertices).");
    };
    return Gemstone;
}());
exports.Gemstone = Gemstone;


/***/ }),

/***/ "./src/ts/geometry.ts":
/*!****************************!*\
  !*** ./src/ts/geometry.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rotateZ = exports.isInsideVolume = exports.isInPlane = exports.cylindric = exports.computeTriangleNormal = exports.computePlaneFromTriangle = exports.computeIntersection = exports.averagePoint = void 0;
function computeTriangleNormal(triangle) {
    var v12 = substraction(triangle.p2, triangle.p1);
    var v13 = substraction(triangle.p3, triangle.p1);
    var normal = crossProduct(v12, v13);
    normalize(normal);
    return normal;
}
exports.computeTriangleNormal = computeTriangleNormal;
function dotProduct(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
}
function crossProduct(v1, v2) {
    return {
        x: v1.y * v2.z - v1.z * v2.y,
        y: v1.z * v2.x - v1.x * v2.z,
        z: v1.x * v2.y - v1.y * v2.x,
    };
}
function substraction(v1, v2) {
    return {
        x: v1.x - v2.x,
        y: v1.y - v2.y,
        z: v1.z - v2.z,
    };
}
function normalize(v) {
    var length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    if (length > 0) {
        v.x /= length;
        v.y /= length;
        v.z /= length;
    }
    else {
        v.x = 1;
        v.y = 0;
        v.z = 0;
    }
}
function averagePoint() {
    var points = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        points[_i] = arguments[_i];
    }
    var result = { x: 0, y: 0, z: 0 };
    for (var _a = 0, points_1 = points; _a < points_1.length; _a++) {
        var point = points_1[_a];
        result.x += point.x;
        result.y += point.y;
        result.z += point.z;
    }
    var nbPoints = points.length;
    result.x /= nbPoints;
    result.y /= nbPoints;
    result.z /= nbPoints;
    return result;
}
exports.averagePoint = averagePoint;
function isInPlane(plane, point) {
    var localCoords = substraction(point, plane.point);
    return Math.abs(dotProduct(plane.normal, localCoords)) < 0.001;
}
exports.isInPlane = isInPlane;
function isInsideVolume(planes, point) {
    for (var _i = 0, planes_1 = planes; _i < planes_1.length; _i++) {
        var plane = planes_1[_i];
        var localCoords = substraction(point, plane.point);
        if (dotProduct(plane.normal, localCoords) > 0.001) {
            return false;
        }
    }
    return true;
}
exports.isInsideVolume = isInsideVolume;
function rotateZ(point, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return {
        x: cos * point.x - sin * point.y,
        y: sin * point.x + cos * point.y,
        z: point.z,
    };
}
exports.rotateZ = rotateZ;
function cylindric(radius, angle, z) {
    return {
        x: radius * Math.cos(angle),
        y: radius * Math.sin(angle),
        z: z,
    };
}
exports.cylindric = cylindric;
function computeIntersection(point, direction, plane) {
    var b = dotProduct(direction, plane.normal);
    if (b !== 0) {
        var a = dotProduct(substraction(plane.point, point), plane.normal);
        var theta = a / b;
        return {
            x: point.x + theta * direction.x,
            y: point.y + theta * direction.y,
            z: point.z + theta * direction.z,
        };
    }
    else {
        return point;
    }
}
exports.computeIntersection = computeIntersection;
function computePlaneFromTriangle(triangle) {
    return {
        point: averagePoint(triangle.p1, triangle.p2, triangle.p3),
        normal: computeTriangleNormal(triangle),
    };
}
exports.computePlaneFromTriangle = computePlaneFromTriangle;


/***/ }),

/***/ "./src/ts/gl-utils/gl-canvas.ts":
/*!**************************************!*\
  !*** ./src/ts/gl-utils/gl-canvas.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gl = exports.initGL = exports.adjustSize = void 0;
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
var gl = null;
exports.gl = gl;
function initGL(flags) {
    function setError(message) {
        Page.Demopage.setErrorMessage("webgl-support", message);
    }
    var canvas = Page.Canvas.getCanvas();
    exports.gl = gl = canvas.getContext("webgl", flags);
    if (gl == null) {
        exports.gl = gl = canvas.getContext("experimental-webgl", flags);
        if (gl == null) {
            setError("Your browser or device does not seem to support WebGL.");
            return false;
        }
        setError("Your browser or device only supports experimental WebGL.\nThe simulation may not run as expected.");
    }
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.clearColor(0, 0, 0, 1);
    return true;
}
exports.initGL = initGL;
function adjustSize(hidpi) {
    if (hidpi === void 0) { hidpi = false; }
    var cssPixel = (hidpi) ? window.devicePixelRatio : 1;
    var canvas = gl.canvas;
    var width = Math.floor(canvas.clientWidth * cssPixel);
    var height = Math.floor(canvas.clientHeight * cssPixel);
    if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
    }
}
exports.adjustSize = adjustSize;


/***/ }),

/***/ "./src/ts/gl-utils/gl-resource.ts":
/*!****************************************!*\
  !*** ./src/ts/gl-utils/gl-resource.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLResource = void 0;
var GLResource = (function () {
    function GLResource(gl) {
        this._gl = gl;
    }
    GLResource.prototype.gl = function () {
        return this._gl;
    };
    return GLResource;
}());
exports.GLResource = GLResource;


/***/ }),

/***/ "./src/ts/gl-utils/shader-manager.ts":
/*!*******************************************!*\
  !*** ./src/ts/gl-utils/shader-manager.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteShader = exports.registerShader = exports.getShader = exports.buildShader = void 0;
var gl_canvas_1 = __webpack_require__(/*! ./gl-canvas */ "./src/ts/gl-utils/gl-canvas.ts");
var shader_1 = __webpack_require__(/*! ./shader */ "./src/ts/gl-utils/shader.ts");
var ShaderSources = __importStar(__webpack_require__(/*! ./shader-sources */ "./src/ts/gl-utils/shader-sources.ts"));
var cachedShaders = {};
function getShader(name) {
    return cachedShaders[name].shader;
}
exports.getShader = getShader;
function buildShader(infos, callback) {
    var sourcesPending = 2;
    var sourcesFailed = 0;
    function loadedSource(success) {
        function processSource(source) {
            return source.replace(/#INJECT\(([^)]*)\)/mg, function (match, name) {
                if (infos.injected[name]) {
                    return infos.injected[name];
                }
                return match;
            });
        }
        sourcesPending--;
        if (!success) {
            sourcesFailed++;
        }
        if (sourcesPending === 0) {
            var shader = null;
            if (sourcesFailed === 0) {
                var vert = ShaderSources.getSource(infos.vertexFilename);
                var frag = ShaderSources.getSource(infos.fragmentFilename);
                var processedVert = processSource(vert);
                var processedFrag = processSource(frag);
                shader = new shader_1.Shader(gl_canvas_1.gl, processedVert, processedFrag);
            }
            callback(shader);
        }
    }
    ShaderSources.loadSource(infos.vertexFilename, loadedSource);
    ShaderSources.loadSource(infos.fragmentFilename, loadedSource);
}
exports.buildShader = buildShader;
function registerShader(name, infos, callback) {
    function callAndClearCallbacks(cached) {
        for (var _i = 0, _a = cached.callbacks; _i < _a.length; _i++) {
            var cachedCallback = _a[_i];
            cachedCallback(!cached.failed, cached.shader);
        }
        cached.callbacks = [];
    }
    if (typeof cachedShaders[name] === "undefined") {
        cachedShaders[name] = {
            callbacks: [callback],
            failed: false,
            infos: infos,
            pending: true,
            shader: null,
        };
        var cached_1 = cachedShaders[name];
        buildShader(infos, function (builtShader) {
            cached_1.pending = false;
            cached_1.failed = builtShader === null;
            cached_1.shader = builtShader;
            callAndClearCallbacks(cached_1);
        });
    }
    else {
        var cached = cachedShaders[name];
        if (cached.pending === true) {
            cached.callbacks.push(callback);
        }
        else {
            callAndClearCallbacks(cached);
        }
    }
}
exports.registerShader = registerShader;
function deleteShader(name) {
    if (typeof cachedShaders[name] !== "undefined") {
        if (cachedShaders[name].shader !== null) {
            cachedShaders[name].shader.freeGLResources();
        }
        delete cachedShaders[name];
    }
}
exports.deleteShader = deleteShader;


/***/ }),

/***/ "./src/ts/gl-utils/shader-sources.ts":
/*!*******************************************!*\
  !*** ./src/ts/gl-utils/shader-sources.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSource = exports.getSource = void 0;
var cachedSources = {};
function loadSource(filename, callback) {
    function callAndClearCallbacks(cached) {
        for (var _i = 0, _a = cached.callbacks; _i < _a.length; _i++) {
            var cachedCallback = _a[_i];
            cachedCallback(!cached.failed);
        }
        cached.callbacks = [];
    }
    if (typeof cachedSources[filename] === "undefined") {
        cachedSources[filename] = {
            callbacks: [callback],
            failed: false,
            pending: true,
            text: null,
        };
        var cached_1 = cachedSources[filename];
        var url = "./shaders/" + filename;
        if (typeof Page.version !== "undefined") {
            url += "?v=" + Page.version;
        }
        var xhr_1 = new XMLHttpRequest();
        xhr_1.open("GET", url, true);
        xhr_1.onload = function () {
            if (xhr_1.readyState === 4) {
                cached_1.pending = false;
                if (xhr_1.status === 200) {
                    cached_1.text = xhr_1.responseText;
                    cached_1.failed = false;
                }
                else {
                    console.error("Cannot load '" + filename + "' shader source: " + xhr_1.statusText);
                    cached_1.failed = true;
                }
                callAndClearCallbacks(cached_1);
            }
        };
        xhr_1.onerror = function () {
            console.error("Cannot load '" + filename + "' shader source: " + xhr_1.statusText);
            cached_1.pending = false;
            cached_1.failed = true;
            callAndClearCallbacks(cached_1);
        };
        xhr_1.send(null);
    }
    else {
        var cached = cachedSources[filename];
        if (cached.pending === true) {
            cached.callbacks.push(callback);
        }
        else {
            cached.callbacks = [callback];
            callAndClearCallbacks(cached);
        }
    }
}
exports.loadSource = loadSource;
function getSource(filename) {
    return cachedSources[filename].text;
}
exports.getSource = getSource;


/***/ }),

/***/ "./src/ts/gl-utils/shader.ts":
/*!***********************************!*\
  !*** ./src/ts/gl-utils/shader.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shader = void 0;
var gl_resource_1 = __webpack_require__(/*! ./gl-resource */ "./src/ts/gl-utils/gl-resource.ts");
function notImplemented() {
    alert("NOT IMPLEMENTED YET");
}
function bindUniformFloat(gl, location, value) {
    if (Array.isArray(value)) {
        gl.uniform1fv(location, value);
    }
    else {
        gl.uniform1f(location, value);
    }
}
function bindUniformFloat2v(gl, location, value) {
    gl.uniform2fv(location, value);
}
function bindUniformFloat3v(gl, location, value) {
    gl.uniform3fv(location, value);
}
function bindUniformFloat4v(gl, location, value) {
    gl.uniform4fv(location, value);
}
function bindUniformInt(gl, location, value) {
    if (Array.isArray(value)) {
        gl.uniform1iv(location, value);
    }
    else {
        gl.uniform1iv(location, value);
    }
}
function bindUniformInt2v(gl, location, value) {
    gl.uniform2iv(location, value);
}
function bindUniformInt3v(gl, location, value) {
    gl.uniform3iv(location, value);
}
function bindUniformInt4v(gl, location, value) {
    gl.uniform4iv(location, value);
}
function bindUniformBool(gl, location, value) {
    gl.uniform1i(location, +value);
}
function bindUniformBool2v(gl, location, value) {
    gl.uniform2iv(location, value);
}
function bindUniformBool3v(gl, location, value) {
    gl.uniform3iv(location, value);
}
function bindUniformBool4v(gl, location, value) {
    gl.uniform4iv(location, value);
}
function bindUniformFloatMat2(gl, location, value) {
    gl.uniformMatrix2fv(location, false, value);
}
function bindUniformFloatMat3(gl, location, value) {
    gl.uniformMatrix3fv(location, false, value);
}
function bindUniformFloatMat4(gl, location, value) {
    gl.uniformMatrix4fv(location, false, value);
}
function bindSampler2D(gl, location, unitNb, value) {
    gl.uniform1i(location, unitNb);
    gl.activeTexture(gl["TEXTURE" + unitNb]);
    gl.bindTexture(gl.TEXTURE_2D, value);
}
function bindSamplerCube(gl, location, unitNb, value) {
    gl.uniform1i(location, unitNb);
    gl.activeTexture(gl["TEXTURE" + unitNb]);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, value);
}
var types = {
    0x8B50: { str: "FLOAT_VEC2", binder: bindUniformFloat2v },
    0x8B51: { str: "FLOAT_VEC3", binder: bindUniformFloat3v },
    0x8B52: { str: "FLOAT_VEC4", binder: bindUniformFloat4v },
    0x8B53: { str: "INT_VEC2", binder: bindUniformInt2v },
    0x8B54: { str: "INT_VEC3", binder: bindUniformInt3v },
    0x8B55: { str: "INT_VEC4", binder: bindUniformInt4v },
    0x8B56: { str: "BOOL", binder: bindUniformBool },
    0x8B57: { str: "BOOL_VEC2", binder: bindUniformBool2v },
    0x8B58: { str: "BOOL_VEC3", binder: bindUniformBool3v },
    0x8B59: { str: "BOOL_VEC4", binder: bindUniformBool4v },
    0x8B5A: { str: "FLOAT_MAT2", binder: bindUniformFloatMat2 },
    0x8B5B: { str: "FLOAT_MAT3", binder: bindUniformFloatMat3 },
    0x8B5C: { str: "FLOAT_MAT4", binder: bindUniformFloatMat4 },
    0x8B5E: { str: "SAMPLER_2D", binder: bindSampler2D },
    0x8B60: { str: "SAMPLER_CUBE", binder: bindSamplerCube },
    0x1400: { str: "BYTE", binder: notImplemented },
    0x1401: { str: "UNSIGNED_BYTE", binder: notImplemented },
    0x1402: { str: "SHORT", binder: notImplemented },
    0x1403: { str: "UNSIGNED_SHORT", binder: notImplemented },
    0x1404: { str: "INT", binder: bindUniformInt },
    0x1405: { str: "UNSIGNED_INT", binder: notImplemented },
    0x1406: { str: "FLOAT", binder: bindUniformFloat },
};
var ShaderProgram = (function (_super) {
    __extends(ShaderProgram, _super);
    function ShaderProgram(gl, vertexSource, fragmentSource) {
        var _this = this;
        function createShader(type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            var compileSuccess = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!compileSuccess) {
                console.error(gl.getShaderInfoLog(shader));
                console.log(source);
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        _this = _super.call(this, gl) || this;
        _this.id = null;
        _this.uCount = 0;
        _this.aCount = 0;
        var vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
        var fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
        var id = gl.createProgram();
        gl.attachShader(id, vertexShader);
        gl.attachShader(id, fragmentShader);
        gl.linkProgram(id);
        var linkSuccess = gl.getProgramParameter(id, gl.LINK_STATUS);
        if (!linkSuccess) {
            console.error(gl.getProgramInfoLog(id));
            gl.deleteProgram(id);
        }
        else {
            _this.id = id;
            _this.introspection();
        }
        return _this;
    }
    ShaderProgram.prototype.freeGLResources = function () {
        _super.prototype.gl.call(this).deleteProgram(this.id);
        this.id = null;
    };
    ShaderProgram.prototype.use = function () {
        _super.prototype.gl.call(this).useProgram(this.id);
    };
    ShaderProgram.prototype.bindUniforms = function () {
        var _this = this;
        var gl = _super.prototype.gl.call(this);
        var currTextureUnitNb = 0;
        Object.keys(this.u).forEach(function (uName) {
            var uniform = _this.u[uName];
            if (uniform.value !== null) {
                if (uniform.type === 0x8B5E || uniform.type === 0x8B60) {
                    var unitNb = currTextureUnitNb;
                    types[uniform.type].binder(gl, uniform.loc, unitNb, uniform.value);
                    currTextureUnitNb++;
                }
                else {
                    types[uniform.type].binder(gl, uniform.loc, uniform.value);
                }
            }
        });
    };
    ShaderProgram.prototype.bindAttributes = function () {
        var _this = this;
        Object.keys(this.a).forEach(function (aName) {
            var attribute = _this.a[aName];
            if (attribute.VBO !== null) {
                attribute.VBO.bind(attribute.loc);
            }
        });
    };
    ShaderProgram.prototype.bindUniformsAndAttributes = function () {
        this.bindUniforms();
        this.bindAttributes();
    };
    ShaderProgram.prototype.introspection = function () {
        var gl = _super.prototype.gl.call(this);
        this.uCount = gl.getProgramParameter(this.id, gl.ACTIVE_UNIFORMS);
        this.u = {};
        for (var i = 0; i < this.uCount; i++) {
            var uniform = gl.getActiveUniform(this.id, i);
            var name_1 = uniform.name;
            this.u[name_1] = {
                loc: gl.getUniformLocation(this.id, name_1),
                size: uniform.size,
                type: uniform.type,
                value: null,
            };
        }
        this.aCount = gl.getProgramParameter(this.id, gl.ACTIVE_ATTRIBUTES);
        this.a = {};
        for (var i = 0; i < this.aCount; i++) {
            var attribute = gl.getActiveAttrib(this.id, i);
            var name_2 = attribute.name;
            this.a[name_2] = {
                VBO: null,
                loc: gl.getAttribLocation(this.id, name_2),
                size: attribute.size,
                type: attribute.type,
            };
        }
    };
    return ShaderProgram;
}(gl_resource_1.GLResource));
exports.Shader = ShaderProgram;


/***/ }),

/***/ "./src/ts/gl-utils/vbo.ts":
/*!********************************!*\
  !*** ./src/ts/gl-utils/vbo.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VBO = void 0;
var gl_resource_1 = __webpack_require__(/*! ./gl-resource */ "./src/ts/gl-utils/gl-resource.ts");
var Usage;
(function (Usage) {
    Usage[Usage["DYNAMIC"] = 0] = "DYNAMIC";
    Usage[Usage["STATIC"] = 1] = "STATIC";
})(Usage || (Usage = {}));
var VBO = (function (_super) {
    __extends(VBO, _super);
    function VBO(gl, array, size, type, staticUsage) {
        if (staticUsage === void 0) { staticUsage = true; }
        var _this = _super.call(this, gl) || this;
        _this.id = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _this.id);
        if (staticUsage) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
        else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        _this.size = size;
        _this.type = type;
        _this.normalize = false;
        _this.stride = 0;
        _this.offset = 0;
        _this.usage = (staticUsage) ? Usage.STATIC : Usage.DYNAMIC;
        return _this;
    }
    VBO.createQuad = function (gl, minX, minY, maxX, maxY) {
        var vert = [
            minX, minY,
            maxX, minY,
            minX, maxY,
            maxX, maxY,
        ];
        return new VBO(gl, new Float32Array(vert), 2, gl.FLOAT, true);
    };
    VBO.prototype.freeGLResources = function () {
        this.gl().deleteBuffer(this.id);
        this.id = null;
    };
    VBO.prototype.bind = function (location) {
        var gl = _super.prototype.gl.call(this);
        gl.enableVertexAttribArray(location);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.id);
        gl.vertexAttribPointer(location, this.size, this.type, this.normalize, this.stride, this.offset);
    };
    VBO.prototype.setData = function (array) {
        var gl = _super.prototype.gl.call(this);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.id);
        if (this.usage === Usage.STATIC) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
        else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    };
    return VBO;
}(gl_resource_1.GLResource));
exports.VBO = VBO;


/***/ }),

/***/ "./src/ts/gl-utils/viewport.ts":
/*!*************************************!*\
  !*** ./src/ts/gl-utils/viewport.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Viewport = void 0;
var Viewport = (function () {
    function Viewport(left, lower, width, height) {
        this.left = left;
        this.lower = lower;
        this.width = width;
        this.height = height;
    }
    Viewport.setFullCanvas = function (gl) {
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    };
    Viewport.prototype.set = function (gl) {
        gl.viewport(this.lower, this.left, this.width, this.height);
    };
    return Viewport;
}());
exports.Viewport = Viewport;


/***/ }),

/***/ "./src/ts/lazy-shader.ts":
/*!*******************************!*\
  !*** ./src/ts/lazy-shader.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyShader = void 0;
var ShaderManager = __importStar(__webpack_require__(/*! ./gl-utils/shader-manager */ "./src/ts/gl-utils/shader-manager.ts"));
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var ELoadingState;
(function (ELoadingState) {
    ELoadingState[ELoadingState["NOT_LOADED"] = 0] = "NOT_LOADED";
    ELoadingState[ELoadingState["LOADING"] = 1] = "LOADING";
    ELoadingState[ELoadingState["LOADED"] = 2] = "LOADED";
})(ELoadingState || (ELoadingState = {}));
var shaderIndex = 0;
var LazyShader = (function () {
    function LazyShader(fragmentShaderName, vertexShaderName, name) {
        this.fragmentShaderName = fragmentShaderName;
        this.vertexShaderName = vertexShaderName;
        this.errorKey = "shader_fail_" + shaderIndex++;
        this.errorMessage = "Failed to load or build the shader '" + name + "'.";
        this.loadingState = ELoadingState.NOT_LOADED;
        this.injected = {};
    }
    Object.defineProperty(LazyShader.prototype, "shader", {
        get: function () {
            if (this.loadingState === ELoadingState.NOT_LOADED) {
                this.requestLoading();
            }
            if (this._shader) {
                return this._shader;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    LazyShader.prototype.reset = function (newInjected) {
        this.loadingState = ELoadingState.NOT_LOADED;
        this.injected = newInjected;
        if (this._shader) {
            this._shader.freeGLResources();
            this._shader = null;
        }
    };
    LazyShader.prototype.requestLoading = function () {
        var _this = this;
        this.loadingState = ELoadingState.LOADING;
        ShaderManager.buildShader({
            fragmentFilename: this.fragmentShaderName,
            vertexFilename: this.vertexShaderName,
            injected: this.injected,
        }, function (builtShader) {
            _this.loadingState = ELoadingState.LOADED;
            if (builtShader !== null) {
                _this._shader = builtShader;
            }
            else {
                Page.Demopage.setErrorMessage(_this.errorKey, _this.errorMessage);
            }
        });
    };
    return LazyShader;
}());
exports.LazyShader = LazyShader;


/***/ }),

/***/ "./src/ts/main.ts":
/*!************************!*\
  !*** ./src/ts/main.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var GLCanvas = __importStar(__webpack_require__(/*! ./gl-utils/gl-canvas */ "./src/ts/gl-utils/gl-canvas.ts"));
var gl_canvas_1 = __webpack_require__(/*! ./gl-utils/gl-canvas */ "./src/ts/gl-utils/gl-canvas.ts");
var viewport_1 = __webpack_require__(/*! ./gl-utils/viewport */ "./src/ts/gl-utils/viewport.ts");
var drawer_1 = __webpack_require__(/*! ./drawer */ "./src/ts/drawer.ts");
var FPSIndicator = __importStar(__webpack_require__(/*! ./fps-indicator */ "./src/ts/fps-indicator.ts"));
var gemstone_1 = __webpack_require__(/*! ./gemstone */ "./src/ts/gemstone.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var utils_1 = __webpack_require__(/*! ./utils */ "./src/ts/utils.ts");
var post_processing_1 = __webpack_require__(/*! ./post-processing */ "./src/ts/post-processing.ts");
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
function main() {
    utils_1.registerPolyfills();
    var webglFlags = {
        alpha: false,
        antialias: false,
        depth: false,
        stencil: false,
        preserveDrawingBuffer: false,
    };
    if (!GLCanvas.initGL(webglFlags)) {
        return;
    }
    var needToAdjustCanvasSize = true;
    parameters_1.Parameters.addCanvasResizeObservers(function () { needToAdjustCanvasSize = true; });
    var drawer = new drawer_1.Drawer(gl_canvas_1.gl);
    var postProcessing = new post_processing_1.PostProcessing(gl_canvas_1.gl);
    function loadGemstone() {
        gemstone_1.Gemstone.loadGemstone(parameters_1.Parameters.cut, function (loadedGemstone) {
            drawer.setGemstone(loadedGemstone);
        });
    }
    parameters_1.Parameters.addCutChangeObserver(loadGemstone);
    loadGemstone();
    var lastLoopUpdate = 0;
    function mainLoop() {
        var now = performance.now();
        var dt = performance.now() - lastLoopUpdate;
        lastLoopUpdate = now;
        FPSIndicator.registerFrame();
        if (needToAdjustCanvasSize) {
            GLCanvas.adjustSize(parameters_1.Parameters.highDPI);
            viewport_1.Viewport.setFullCanvas(gl_canvas_1.gl);
            needToAdjustCanvasSize = false;
        }
        if (parameters_1.Parameters.autoRotate && !Page.Canvas.isMouseDown()) {
            drawer.rotate(dt * 0.0001);
        }
        if (parameters_1.Parameters.displayRaytracedVolume) {
            drawer.drawDebugVolume();
        }
        else {
            if (parameters_1.Parameters.postProcessing && postProcessing.isReady()) {
                postProcessing.prepare();
                drawer.draw();
                postProcessing.apply();
            }
            else {
                drawer.draw();
            }
        }
        requestAnimationFrame(mainLoop);
    }
    mainLoop();
}
main();


/***/ }),

/***/ "./src/ts/orbital-camera.ts":
/*!**********************************!*\
  !*** ./src/ts/orbital-camera.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrbitalCamera = void 0;
var OrbitalCamera = (function () {
    function OrbitalCamera(focusPoint, distance) {
        this._focus = focusPoint;
        this._distance = distance;
        this._theta = 0;
        this._phi = 0.01;
        this._eyePos = [0, 0, 0];
        this._viewMatrix = mat4.create();
        this.recompute();
    }
    Object.defineProperty(OrbitalCamera.prototype, "focusPoint", {
        get: function () {
            return this._focus;
        },
        set: function (newFocus) {
            this._focus = newFocus;
            this.recompute();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrbitalCamera.prototype, "distance", {
        get: function () {
            return this._distance;
        },
        set: function (newDistance) {
            this._distance = newDistance;
            this.recompute();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrbitalCamera.prototype, "theta", {
        get: function () {
            return this._theta;
        },
        set: function (newTheta) {
            this._theta = newTheta;
            this.recompute();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrbitalCamera.prototype, "phi", {
        get: function () {
            return this._phi;
        },
        set: function (newPhi) {
            this._phi = newPhi;
            this.recompute();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrbitalCamera.prototype, "eyePos", {
        get: function () {
            return this._eyePos;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrbitalCamera.prototype, "viewMatrix", {
        get: function () {
            return this._viewMatrix;
        },
        enumerable: false,
        configurable: true
    });
    OrbitalCamera.prototype.recompute = function () {
        var sin = Math.sin;
        var cos = Math.cos;
        this._eyePos[0] = this.focusPoint[0] + this.distance * (sin(this.phi) * cos(this.theta));
        this._eyePos[1] = this.focusPoint[1] + this.distance * (sin(this.phi) * sin(this.theta));
        this._eyePos[2] = this.focusPoint[2] + this.distance * (cos(this.phi));
        this._viewMatrix = mat4.lookAt(this._viewMatrix, this.eyePos, this.focusPoint, [0, 0, 1]);
    };
    return OrbitalCamera;
}());
exports.OrbitalCamera = OrbitalCamera;


/***/ }),

/***/ "./src/ts/page-interface-generated.ts":
/*!********************************************!*\
  !*** ./src/ts/page-interface-generated.ts ***!
  \********************************************/
/***/ (function() {




/***/ }),

/***/ "./src/ts/parameters.ts":
/*!******************************!*\
  !*** ./src/ts/parameters.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameters = exports.EProjection = exports.ELightType = exports.ELightDirection = void 0;
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var controlId = {
    CUT_PICKER_ID: "gem-cut-picker-id",
    REFRACTION_RANGE_ID: "refraction-range-id",
    GEM_COLOR_PICKER: "gem-color-picker-id",
    GEM_ABSOPTION_RANGE_ID: "absorption-range-id",
    DISPERSION_RANGE_ID: "dispersion-range-id",
    RAY_DEPTH_RANGE_ID: "ray-depth-range-id",
    REFLECTION: "reflection-checkbox-id",
    DISPLAY_SKYBOX_CHECKBOX_ID: "display-skybox-checkbox-id",
    BACKGROUND_COLOR_PICKER: "background-color-picker-id",
    PROJECTION_TABS_ID: "projection-tabs-id",
    GEOMETRY_ONLY_CHECKBOX_ID: "only-normals-checkbox-id",
    AUTO_ROTATE_CHECKBOX_ID: "auto-rotate-checkbox-id",
    POST_PROCESSING_CHECKBOX_ID: "post-processing-checkbox-id",
    HIGH_DPI_CHEKBOX_ID: "high-dpi-checkbox-id",
    LIGHT_TYPE_TABS_ID: "light-type-tabs-id",
    LIGHT_DIRECTION_TABS_ID: "light-direction-tabs-id",
    DISPLAY_INDICATORS: "display-indicators-checkbox-id",
    RAYTRACED_VOLUME: "raytraced-volume-checkbox-id",
    DISPLAY_NORMALS: "display-normals-checkbox-id",
    VERBOSE: "verbose-checkbox-id",
    CUSTOM_CUT_CROWN_HEIGHT: "custom-cut-crown-height-range-id",
    CUSTOM_CUT_CROWN_TABLE: "custom-cut-crown-table-range-id",
    CUSTOM_CUT_CROWN_RATIO: "custom-cut-crown-ratio-range-id",
    CUSTOM_CUT_GIRDLE_THICKNESS: "custom-cut-girdle-thickness-range-id",
    CUSTOM_CUT_GIRDLE_ROUNDNESS: "custom-cut-girdle-roundness-range-id",
    CUSTOM_CUT_PAVILLION_HEIGHT: "custom-cut-pavillion-height-range-id",
    CUSTOM_CUT_PAVILLION_RATIO: "custom-cut-pavillion-ratio-range-id",
};
var ELightType;
(function (ELightType) {
    ELightType["WHITE"] = "white";
    ELightType["ASET"] = "aset";
})(ELightType || (ELightType = {}));
exports.ELightType = ELightType;
var ELightDirection;
(function (ELightDirection) {
    ELightDirection["DOWNWARD"] = "downward";
    ELightDirection["UPWARD"] = "upward";
})(ELightDirection || (ELightDirection = {}));
exports.ELightDirection = ELightDirection;
var EProjection;
(function (EProjection) {
    EProjection["PERSPECTIVE"] = "perspective";
    EProjection["ORTHOGRAPHIC"] = "orthographic";
})(EProjection || (EProjection = {}));
exports.EProjection = EProjection;
function callObservers(observers) {
    for (var _i = 0, observers_1 = observers; _i < observers_1.length; _i++) {
        var observer = observers_1[_i];
        observer();
    }
}
var cutChangeObservers = [];
var callCutChangeObservers = function () { callObservers(cutChangeObservers); };
Page.Picker.addObserver(controlId.CUT_PICKER_ID, callCutChangeObservers);
Page.Range.addLazyObserver(controlId.CUSTOM_CUT_CROWN_HEIGHT, callCutChangeObservers);
Page.Range.addLazyObserver(controlId.CUSTOM_CUT_CROWN_TABLE, callCutChangeObservers);
Page.Range.addLazyObserver(controlId.CUSTOM_CUT_CROWN_RATIO, callCutChangeObservers);
Page.Range.addLazyObserver(controlId.CUSTOM_CUT_GIRDLE_THICKNESS, callCutChangeObservers);
Page.Range.addLazyObserver(controlId.CUSTOM_CUT_GIRDLE_ROUNDNESS, callCutChangeObservers);
Page.Range.addLazyObserver(controlId.CUSTOM_CUT_PAVILLION_HEIGHT, callCutChangeObservers);
Page.Range.addLazyObserver(controlId.CUSTOM_CUT_PAVILLION_RATIO, callCutChangeObservers);
var recomputeShaderObservers = [];
var callRecomputeShaderObservers = function () { callObservers(recomputeShaderObservers); };
Page.Range.addLazyObserver(controlId.RAY_DEPTH_RANGE_ID, callRecomputeShaderObservers);
var canvasResizeObservers = [];
var callCanvasResizeObservers = function () { callObservers(canvasResizeObservers); };
Page.Canvas.Observers.canvasResize.push(callCanvasResizeObservers);
Page.Checkbox.addObserver(controlId.HIGH_DPI_CHEKBOX_ID, callCanvasResizeObservers);
var cameraChangeObservers = [];
var callCameraChangeObservers = function () { callObservers(cameraChangeObservers); };
Page.Tabs.addObserver(controlId.PROJECTION_TABS_ID, callCameraChangeObservers);
var backgroundColorChangeObservers = [];
var backgroundColor = { r: 0, g: 0, b: 0 };
function updateBackgroundColor() {
    var rgb = Page.ColorPicker.getValue(controlId.BACKGROUND_COLOR_PICKER);
    backgroundColor.r = rgb.r;
    backgroundColor.g = rgb.g;
    backgroundColor.b = rgb.b;
    callObservers(backgroundColorChangeObservers);
}
Page.ColorPicker.addObserver(controlId.BACKGROUND_COLOR_PICKER, updateBackgroundColor);
updateBackgroundColor();
var gemColor = { r: 0, g: 0, b: 0 };
function updateGemColor() {
    var rgb = Page.ColorPicker.getValue(controlId.GEM_COLOR_PICKER);
    gemColor.r = rgb.r;
    gemColor.g = rgb.g;
    gemColor.b = rgb.b;
}
Page.ColorPicker.addObserver(controlId.GEM_COLOR_PICKER, updateGemColor);
updateGemColor();
var Parameters = (function () {
    function Parameters() {
    }
    Object.defineProperty(Parameters, "cut", {
        get: function () {
            return Page.Picker.getValue(controlId.CUT_PICKER_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "refractionIndex", {
        get: function () {
            return Page.Range.getValue(controlId.REFRACTION_RANGE_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "displaySkybox", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.DISPLAY_SKYBOX_CHECKBOX_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "backgroundColor", {
        get: function () {
            return backgroundColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "gemColor", {
        get: function () {
            return gemColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "absorption", {
        get: function () {
            return Page.Range.getValue(controlId.GEM_ABSOPTION_RANGE_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "dispersion", {
        get: function () {
            return Page.Range.getValue(controlId.DISPERSION_RANGE_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "rayDepth", {
        get: function () {
            return Math.ceil(Page.Range.getValue(controlId.RAY_DEPTH_RANGE_ID));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "displayReflection", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.REFLECTION);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "displayRaytracedVolume", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.RAYTRACED_VOLUME);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "displayNormals", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.DISPLAY_NORMALS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "verbose", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.VERBOSE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "projection", {
        get: function () {
            return Page.Tabs.getValues(controlId.PROJECTION_TABS_ID)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "geometryOnly", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.GEOMETRY_ONLY_CHECKBOX_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "autoRotate", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.AUTO_ROTATE_CHECKBOX_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "postProcessing", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.POST_PROCESSING_CHECKBOX_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "highDPI", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.HIGH_DPI_CHEKBOX_ID);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "lightType", {
        get: function () {
            return Page.Tabs.getValues(controlId.LIGHT_TYPE_TABS_ID)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "lightDirection", {
        get: function () {
            return Page.Tabs.getValues(controlId.LIGHT_DIRECTION_TABS_ID)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "customCutCrownHeight", {
        get: function () {
            return Page.Range.getValue(controlId.CUSTOM_CUT_CROWN_HEIGHT);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "customCutCrownTable", {
        get: function () {
            return Page.Range.getValue(controlId.CUSTOM_CUT_CROWN_TABLE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "customCutCrownRatio", {
        get: function () {
            return Page.Range.getValue(controlId.CUSTOM_CUT_CROWN_RATIO);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "customCutGirdleThickness", {
        get: function () {
            return Page.Range.getValue(controlId.CUSTOM_CUT_GIRDLE_THICKNESS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "customCutGirdleRoundess", {
        get: function () {
            return Page.Range.getValue(controlId.CUSTOM_CUT_GIRDLE_ROUNDNESS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "customCutPavillionHeight", {
        get: function () {
            return Page.Range.getValue(controlId.CUSTOM_CUT_PAVILLION_HEIGHT);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "customCutPavillionRati", {
        get: function () {
            return Page.Range.getValue(controlId.CUSTOM_CUT_PAVILLION_RATIO);
        },
        enumerable: false,
        configurable: true
    });
    Parameters.addCutChangeObserver = function (observer) {
        cutChangeObservers.push(observer);
    };
    Parameters.addBackgroundColorObserver = function (observer) {
        backgroundColorChangeObservers.push(observer);
    };
    Parameters.addRecomputeShaderObservers = function (observer) {
        recomputeShaderObservers.push(observer);
    };
    Parameters.addCanvasResizeObservers = function (observer) {
        canvasResizeObservers.push(observer);
    };
    Parameters.addCameraChangeObservers = function (observer) {
        cameraChangeObservers.push(observer);
    };
    return Parameters;
}());
exports.Parameters = Parameters;
function updateCustomCutSection() {
    Page.Sections.setVisibility("custom-cut-section", Parameters.cut === "CUSTOM CUT");
}
Parameters.addCutChangeObserver(updateCustomCutSection);
updateCustomCutSection();
Page.Controls.setVisibility(controlId.HIGH_DPI_CHEKBOX_ID, window.devicePixelRatio > 1);
function updateIndicatorsVisibility() {
    var visible = Page.Checkbox.isChecked(controlId.DISPLAY_INDICATORS);
    Page.Canvas.setIndicatorsVisibility(visible);
}
Page.Checkbox.addObserver(controlId.DISPLAY_INDICATORS, updateIndicatorsVisibility);
updateIndicatorsVisibility();
function updateBackgroundVisibility() {
    Page.Controls.setVisibility(controlId.BACKGROUND_COLOR_PICKER, !Parameters.displaySkybox);
}
Page.Checkbox.addObserver(controlId.DISPLAY_SKYBOX_CHECKBOX_ID, updateBackgroundVisibility);
updateBackgroundVisibility();
{
    var isInDebug = false;
    if (typeof URLSearchParams !== "undefined") {
        var urlParams = new URLSearchParams(window.location.search);
        isInDebug = urlParams.get('debug') === "1";
    }
    Page.Sections.setVisibility("debug-section-id", isInDebug);
}


/***/ }),

/***/ "./src/ts/post-processing.ts":
/*!***********************************!*\
  !*** ./src/ts/post-processing.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PostProcessing = void 0;
var vbo_1 = __webpack_require__(/*! ./gl-utils/vbo */ "./src/ts/gl-utils/vbo.ts");
var lazy_shader_1 = __webpack_require__(/*! ./lazy-shader */ "./src/ts/lazy-shader.ts");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var SQUARE = new Float32Array([
    -1, -1,
    +1, -1,
    -1, +1,
    +1, +1,
]);
var PostProcessing = (function () {
    function PostProcessing(gl) {
        this.gl = gl;
        this.squareVBO = new vbo_1.VBO(gl, SQUARE, 2, gl.FLOAT, true);
        this.downsizingShader = new lazy_shader_1.LazyShader("post-processing/downsizing.frag", "post-processing/fullscreen.vert", "post-processing downsizing");
        this.blurShader = new lazy_shader_1.LazyShader("post-processing/blur.frag", "post-processing/fullscreen.vert", "post-processing blur");
        this.blurShader.reset({
            BLUR_INSTRUCTIONS: PostProcessing.buildGlowInstructions1D(3),
        });
        this.compositingShader = new lazy_shader_1.LazyShader("post-processing/compositing.frag", "post-processing/fullscreen.vert", "post-processing downsizing");
        this.fullSizeTexture = this.createTexture();
        this.downsizedTexture = this.createTexture();
        this.downsizedBlurredTexture = this.createTexture();
    }
    PostProcessing.prototype.isReady = function () {
        var downsizingIsReady = !!this.downsizingShader.shader;
        var blurIsReady = !!this.blurShader.shader;
        var compositingIsReady = !!this.compositingShader.shader;
        return downsizingIsReady && blurIsReady && compositingIsReady;
    };
    PostProcessing.prototype.prepare = function () {
        var dpiScaling = parameters_1.Parameters.highDPI ? window.devicePixelRatio : 1;
        var smallerTextureScaling = 1 / (8 * dpiScaling);
        this.initializeTexture(this.fullSizeTexture, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        this.initializeTexture(this.downsizedTexture, smallerTextureScaling * this.fullSizeTexture.width, smallerTextureScaling * this.fullSizeTexture.height);
        this.initializeTexture(this.downsizedBlurredTexture, this.downsizedTexture.width, this.downsizedTexture.height);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fullSizeTexture.framebuffer);
        this.gl.viewport(0, 0, this.fullSizeTexture.width, this.fullSizeTexture.height);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    };
    PostProcessing.prototype.apply = function () {
        var downsizingShader = this.downsizingShader.shader;
        var blurShader = this.blurShader.shader;
        var compositingShader = this.compositingShader.shader;
        if (downsizingShader && blurShader && compositingShader) {
            {
                downsizingShader.a["aCorner"].VBO = this.squareVBO;
                downsizingShader.u["uTexture"].value = this.fullSizeTexture.texture;
                downsizingShader.use();
                downsizingShader.bindUniformsAndAttributes();
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.downsizedTexture.framebuffer);
                this.gl.viewport(0, 0, this.downsizedTexture.width, this.downsizedTexture.height);
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
            {
                blurShader.a["aCorner"].VBO = this.squareVBO;
                blurShader.u["uTexture"].value = this.downsizedTexture.texture;
                blurShader.u["uTexelSize"].value = [1 / this.downsizedTexture.width, 1 / this.downsizedTexture.height];
                blurShader.use();
                blurShader.bindUniformsAndAttributes();
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.downsizedBlurredTexture.framebuffer);
                this.gl.viewport(0, 0, this.downsizedBlurredTexture.width, this.downsizedBlurredTexture.height);
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
            {
                compositingShader.a["aCorner"].VBO = this.squareVBO;
                compositingShader.u["uFullsizeTexture"].value = this.fullSizeTexture.texture;
                compositingShader.u["uFullsizeTextureTexelSize"].value = [1 / this.fullSizeTexture.width, 1 / this.fullSizeTexture.height];
                compositingShader.u["uBlurredTexture"].value = this.downsizedBlurredTexture.texture;
                compositingShader.use();
                compositingShader.bindUniformsAndAttributes();
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            }
        }
    };
    PostProcessing.prototype.initializeTexture = function (texture, wantedWidth, wantedHeight) {
        wantedWidth = Math.ceil(wantedWidth);
        wantedHeight = Math.ceil(wantedHeight);
        if (texture.width !== wantedWidth || texture.height !== wantedHeight) {
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texture);
            var format = this.gl.RGBA;
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, format, wantedWidth, wantedHeight, 0, format, this.gl.UNSIGNED_BYTE, null);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.framebuffer);
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture.texture, 0);
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            texture.width = wantedWidth;
            texture.height = wantedHeight;
        }
    };
    PostProcessing.prototype.createTexture = function () {
        return {
            texture: this.gl.createTexture(),
            framebuffer: this.gl.createFramebuffer(),
            width: -1,
            height: -1,
        };
    };
    PostProcessing.buildGlowInstructions1D = function (radius) {
        var sigma = 8;
        function factor(x) {
            return Math.exp(-(x * x) / (2 * sigma * sigma)) / Math.sqrt(2 * Math.PI * sigma * sigma);
        }
        var total = 0;
        for (var i = -radius - 0.5; i <= radius; i++) {
            total += factor(i);
        }
        var instructions = [];
        for (var i = -radius - 0.5; i <= radius + 0.5; i++) {
            instructions.push("blurred += " + factor(i) / total + " * contribution(vec2(" + i + ", " + i + "));");
            instructions.push("blurred += " + factor(i) / total + " * contribution(vec2(" + i + ", " + -i + "));");
        }
        instructions.push("blurred *= 0.5;");
        instructions.push("blurred *= 0.5;");
        return instructions.join("\n\t");
    };
    return PostProcessing;
}());
exports.PostProcessing = PostProcessing;


/***/ }),

/***/ "./src/ts/utils.ts":
/*!*************************!*\
  !*** ./src/ts/utils.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerPolyfills = void 0;
function traceRegistration(name) {
    console.log("Registering polyfill for '" + name + "'.");
}
function registerStringStartsWithPolyfill() {
    if (typeof String.prototype.startsWith !== "function") {
        traceRegistration("String.startsWith");
        String.prototype.startsWith = function (tested) {
            return this.indexOf(tested) === 0;
        };
    }
}
function registerPolyfills() {
    registerStringStartsWithPolyfill();
}
exports.registerPolyfills = registerPolyfills;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/main.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.min.js.map